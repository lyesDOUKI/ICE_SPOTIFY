"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
var Ice = require("../Ice/ModuleRegistry").Ice;

var _toString = function toString(key, object, objectTable, ident) {
  ident += "  ";

  if (object === null) {
    return "\n" + ident + key + ": (null)";
  }

  if (object === undefined) {
    return "\n" + ident + key + ": (undefined)";
  }

  if (key == "stack" || typeof object == "function") {
    return "";
  }

  if (_typeof(object) != "object") {
    return "\n" + ident + key + ": \"" + object + "\"";
  }

  if (objectTable.indexOf(object) != -1) {
    return "\n" + ident + key + ": (recursive)";
  }

  objectTable.push(object);
  var s = "\n" + ident + key + ":";

  for (var k in object) {
    if (key.indexOf("_") === 0) {
      continue;
    }

    if (typeof object[k] == "function") {
      continue;
    }

    s += ident + _toString(k, object[k], objectTable, ident);
  }

  return s;
}; //
// Ice.Exception
//


var Exception = /*#__PURE__*/function (_Error) {
  _inherits(Exception, _Error);

  var _super = _createSuper(Exception);

  function Exception(cause) {
    var _this;

    _classCallCheck(this, Exception);

    _this = _super.call(this);

    if (cause) {
      _this.ice_cause = cause;
    }

    return _this;
  }

  _createClass(Exception, [{
    key: "ice_name",
    value: function ice_name() {
      return this.constructor._id.substr(2);
    }
  }, {
    key: "ice_id",
    value: function ice_id() {
      return this.constructor._id;
    }
  }, {
    key: "toString",
    value: function toString() {
      //
      // We have a guard here to prevent being re-entered. With some browsers (IE), accessing
      // the stack property ends up calling toString on the exception to print it out with the
      // stack.
      //
      if (this._inToStringAlready) {
        return "";
      }

      this._inToStringAlready = true;
      var s = this.ice_id();

      for (var key in this) {
        if (key != "_inToStringAlready") {
          s += _toString(key, this[key], [], "");
        }
      }

      if (Ice._printStackTraces === true && this.stack) {
        s += "\n" + this.stack;
      }

      this._inToStringAlready = false;
      return s;
    }
  }], [{
    key: "_id",
    get: function get() {
      return "::Ice::Exception";
    }
  }, {
    key: "captureStackTrace",
    value: function captureStackTrace(object) {
      var stack = new Error().stack; //
      // In IE 10 and greater the stack will be filled once the Error is throw
      // we don't need to do anything.
      //

      if (stack !== undefined) {
        Object.defineProperty(object, "stack", {
          get: function get() {
            return stack;
          }
        });
      }
    }
  }]);

  return Exception;
}( /*#__PURE__*/_wrapNativeSuper(Error));

Ice.Exception = Exception; //
// Ice.LocalException
//

var LocalException = /*#__PURE__*/function (_Exception) {
  _inherits(LocalException, _Exception);

  var _super2 = _createSuper(LocalException);

  function LocalException(cause) {
    var _this2;

    _classCallCheck(this, LocalException);

    _this2 = _super2.call(this, cause);
    Exception.captureStackTrace(_assertThisInitialized(_this2));
    return _this2;
  }

  _createClass(LocalException, null, [{
    key: "_id",
    get: function get() {
      return "::Ice::LocalException";
    }
  }]);

  return LocalException;
}(Exception);

Ice.LocalException = LocalException; //
// Ice.UserException
//

var UserException = /*#__PURE__*/function (_Exception2) {
  _inherits(UserException, _Exception2);

  var _super3 = _createSuper(UserException);

  function UserException(cause) {
    var _this3;

    _classCallCheck(this, UserException);

    _this3 = _super3.call(this, cause);
    Exception.captureStackTrace(_assertThisInitialized(_this3));
    return _this3;
  }

  _createClass(UserException, [{
    key: "ice_getSlicedData",
    value: function ice_getSlicedData() {
      return null;
    }
  }, {
    key: "_write",
    value: function _write(os) {
      os.startException(null);
      writeImpl(this, os, this._mostDerivedType());
      os.endException();
    }
  }, {
    key: "_read",
    value: function _read(is) {
      is.startException();
      readImpl(this, is, this._mostDerivedType());
      is.endException(false);
    }
  }, {
    key: "_usesClasses",
    value: function _usesClasses() {
      return false;
    }
  }, {
    key: "_mostDerivedType",
    value: function _mostDerivedType() {
      return Ice.UserException;
    }
  }], [{
    key: "_id",
    get: function get() {
      return "::Ice::UserException";
    }
  }]);

  return UserException;
}(Exception);

Ice.UserException = UserException; //
// Private methods
//

var writeImpl = function writeImpl(obj, os, type) {
  //
  // The writeImpl method is a recursive method that goes down the
  // class hierarchy to marshal each slice of the class using the
  // generated _writeMemberImpl method.
  //
  if (type === undefined || type === UserException) {
    return; // Don't marshal anything for Ice.UserException
  }

  os.startSlice(type._id, -1, type._parent === UserException);

  if (type.prototype.hasOwnProperty('_writeMemberImpl')) {
    type.prototype._writeMemberImpl.call(obj, os);
  }

  os.endSlice();
  writeImpl(obj, os, type._parent);
};

var readImpl = function readImpl(obj, is, type) {
  //
  // The readImpl method is a recursive method that goes down the
  // class hierarchy to marshal each slice of the class using the
  // generated _readMemberImpl method.
  //
  if (type === undefined || type === UserException) {
    return; // Don't marshal anything for UserException
  }

  is.startSlice();

  if (type.prototype.hasOwnProperty('_readMemberImpl')) {
    type.prototype._readMemberImpl.call(obj, is);
  }

  is.endSlice();
  readImpl(obj, is, type._parent);
};

var writePreserved = function writePreserved(os) {
  //
  // For Slice exceptions which are marked "preserved", the implementation of this method
  // replaces the Ice.UserException.prototype._write method.
  //
  os.startException(this._slicedData);
  writeImpl(this, os, this._mostDerivedType());
  os.endException();
};

var readPreserved = function readPreserved(is) {
  //
  // For Slice exceptions which are marked "preserved", the implementation of this method
  // replaces the Ice.UserException.prototype._read method.
  //
  is.startException();
  readImpl(this, is, this._mostDerivedType());
  this._slicedData = is.endException(true);
};

var ice_getSlicedData = function ice_getSlicedData() {
  return this._slicedData;
};

Ice.Slice.PreservedUserException = function (ex) {
  ex.prototype.ice_getSlicedData = ice_getSlicedData;
  ex.prototype._write = writePreserved;
  ex.prototype._read = readPreserved;
};

module.exports.Ice = Ice;