"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
var Ice = require("../Ice/ModuleRegistry").Ice;

require("../Ice/ConnectionInfo");

require("../Ice/Debug");

require("../Ice/Exception");

require("../Ice/LocalException");

require("../Ice/SocketOperation");

require("../Ice/Timer");

var IceSSL = Ice._ModuleRegistry.module("IceSSL");

var _WSTransceiver = {};

if (typeof WebSocket !== 'undefined') {
  var fdToString = function fdToString(address) {
    return "local address = <not available>\nremote address = " + address.host + ":" + address.port;
  };

  var translateError = function translateError(state, err) {
    if (state < StateConnected) {
      return new Ice.ConnectFailedException(err.code, err);
    } else {
      if (err.code === 1000 || err.code === 1006) // CLOSE_NORMAL | CLOSE_ABNORMAL
        {
          return new Ice.ConnectionLostException();
        }

      return new Ice.SocketException(err.code, err);
    }
  };

  //
  // With Chrome we don't want to close the socket while connection is in progress,
  // see comments on close implementation below.
  //
  // We need to check for Edge browser as it might include Chrome in its user agent.
  //
  var IsChrome = navigator.userAgent.indexOf("Edge/") === -1 && navigator.userAgent.indexOf("Chrome/") !== -1;
  var IsSafari = /^((?!chrome).)*safari/i.test(navigator.userAgent);
  var Debug = Ice.Debug;
  var SocketOperation = Ice.SocketOperation;
  var Timer = Ice.Timer;
  var StateNeedConnect = 0;
  var StateConnectPending = 1;
  var StateConnected = 2;
  var StateClosePending = 3;
  var StateClosed = 4;

  _WSTransceiver = /*#__PURE__*/function () {
    function WSTransceiver(instance) {
      _classCallCheck(this, WSTransceiver);

      this._readBuffers = [];
      this._readPosition = 0;
      this._maxSendPacketSize = instance.properties().getPropertyAsIntWithDefault("Ice.TCP.SndSize", 512 * 1024);
      this._writeReadyTimeout = 0;
    }

    _createClass(WSTransceiver, [{
      key: "writeReadyTimeout",
      value: function writeReadyTimeout() {
        var t = Math.round(this._writeReadyTimeout);
        this._writeReadyTimeout += this._writeReadyTimeout >= 5 ? 5 : 0.2;
        return Math.min(t, 25);
      }
    }, {
      key: "setCallbacks",
      value: function setCallbacks(connectedCallback, bytesAvailableCallback, bytesWrittenCallback) {
        this._connectedCallback = connectedCallback;
        this._bytesAvailableCallback = bytesAvailableCallback;
        this._bytesWrittenCallback = bytesWrittenCallback;
      } //
      // Returns SocketOperation.None when initialization is complete.
      //

    }, {
      key: "initialize",
      value: function initialize(readBuffer, writeBuffer) {
        var _this = this;

        try {
          if (this._exception) {
            throw this._exception;
          }

          if (this._state === StateNeedConnect) {
            this._state = StateConnectPending;
            this._fd = new WebSocket(this._url, "ice.zeroc.com");
            this._fd.binaryType = "arraybuffer";

            this._fd.onopen = function (e) {
              return _this.socketConnected(e);
            };

            this._fd.onmessage = function (e) {
              return _this.socketBytesAvailable(e.data);
            };

            this._fd.onclose = function (e) {
              return _this.socketClosed(e);
            };

            return SocketOperation.Connect; // Waiting for connect to complete.
          } else if (this._state === StateConnectPending) {
            //
            // Socket is connected.
            //
            this._desc = fdToString(this._addr);
            this._state = StateConnected;
          }
        } catch (err) {
          if (!this._exception) {
            this._exception = translateError(this._state, err);
          }

          throw this._exception;
        }

        Debug.assert(this._state === StateConnected);
        return SocketOperation.None;
      }
    }, {
      key: "register",
      value: function register() {
        var _this2 = this;

        //
        // Register the socket data listener.
        //
        this._registered = true;

        if (this._hasBytesAvailable || this._exception) {
          this._hasBytesAvailable = false;
          Timer.setTimeout(function () {
            return _this2._bytesAvailableCallback();
          }, 0);
        }
      }
    }, {
      key: "unregister",
      value: function unregister() {
        //
        // Unregister the socket data listener.
        //
        this._registered = false;
      }
    }, {
      key: "close",
      value: function close() {
        if (this._fd === null) {
          Debug.assert(this._exception); // Websocket creation failed.

          return;
        } //
        // With Chrome (in particular on macOS) calling close() while the websocket isn't
        // connected yet doesn't abort the connection attempt, and might result in the
        // connection being reused by a different web socket.
        //
        // To workaround this problem, we always wait for the socket to be connected or
        // closed before closing the socket.
        //
        // NOTE: when this workaround is no longer necessary, don't forget removing the
        // StateClosePending state.
        //


        if ((IsChrome || IsSafari) && this._fd.readyState === WebSocket.CONNECTING) {
          this._state = StateClosePending;
          return;
        }

        Debug.assert(this._fd !== null);

        try {
          this._state = StateClosed;

          this._fd.close();
        } catch (ex) {
          throw translateError(this._state, ex);
        } finally {
          this._fd = null;
        }
      } //
      // Returns true if all of the data was flushed to the kernel buffer.
      //

    }, {
      key: "write",
      value: function write(byteBuffer) {
        var _this3 = this;

        if (this._exception) {
          throw this._exception;
        } else if (byteBuffer.remaining === 0) {
          return true;
        }

        Debug.assert(this._fd);

        var cb = function cb() {
          if (_this3._fd) {
            var packetSize = _this3._maxSendPacketSize > 0 && byteBuffer.remaining > _this3._maxSendPacketSize ? _this3._maxSendPacketSize : byteBuffer.remaining;

            if (_this3._fd.bufferedAmount + packetSize <= _this3._maxSendPacketSize) {
              _this3._bytesWrittenCallback(0, 0);
            } else {
              Timer.setTimeout(cb, _this3.writeReadyTimeout());
            }
          }
        };

        while (true) {
          var packetSize = this._maxSendPacketSize > 0 && byteBuffer.remaining > this._maxSendPacketSize ? this._maxSendPacketSize : byteBuffer.remaining;

          if (byteBuffer.remaining === 0) {
            break;
          }

          Debug.assert(packetSize > 0);

          if (this._fd.bufferedAmount + packetSize > this._maxSendPacketSize) {
            Timer.setTimeout(cb, this.writeReadyTimeout());
            return false;
          }

          this._writeReadyTimeout = 0;
          var slice = byteBuffer.b.slice(byteBuffer.position, byteBuffer.position + packetSize);

          this._fd.send(slice);

          byteBuffer.position += packetSize; //
          // TODO: WORKAROUND for Safari issue. The websocket accepts all the
          // data (bufferedAmount is always 0). We relinquish the control here
          // to ensure timeouts work properly.
          //

          if (IsSafari && byteBuffer.remaining > 0) {
            Timer.setTimeout(cb, this.writeReadyTimeout());
            return false;
          }
        }

        return true;
      }
    }, {
      key: "read",
      value: function read(byteBuffer, moreData) {
        if (this._exception) {
          throw this._exception;
        }

        moreData.value = false;

        if (this._readBuffers.length === 0) {
          return false; // No data available.
        }

        var avail = this._readBuffers[0].byteLength - this._readPosition;
        Debug.assert(avail > 0);

        while (byteBuffer.remaining > 0) {
          if (avail > byteBuffer.remaining) {
            avail = byteBuffer.remaining;
          }

          new Uint8Array(byteBuffer.b).set(new Uint8Array(this._readBuffers[0], this._readPosition, avail), byteBuffer.position);
          byteBuffer.position += avail;
          this._readPosition += avail;

          if (this._readPosition === this._readBuffers[0].byteLength) {
            //
            // We've exhausted the current read buffer.
            //
            this._readPosition = 0;

            this._readBuffers.shift();

            if (this._readBuffers.length === 0) {
              break; // No more data - we're done.
            } else {
              avail = this._readBuffers[0].byteLength;
            }
          }
        }

        moreData.value = this._readBuffers.length > 0;
        return byteBuffer.remaining === 0;
      }
    }, {
      key: "type",
      value: function type() {
        return this._secure ? "wss" : "ws";
      }
    }, {
      key: "getInfo",
      value: function getInfo() {
        Debug.assert(this._fd !== null);
        var info = new Ice.WSConnectionInfo();
        var tcpinfo = new Ice.TCPConnectionInfo();
        tcpinfo.localAddress = "";
        tcpinfo.localPort = -1;
        tcpinfo.remoteAddress = this._addr.host;
        tcpinfo.remotePort = this._addr.port;
        info.underlying = this._secure ? new IceSSL.ConnectionInfo(tcpinfo, tcpinfo.timeout, tcpinfo.compress) : tcpinfo;
        info.rcvSize = -1;
        info.sndSize = this._maxSendPacketSize;
        info.headers = {};
        return info;
      }
    }, {
      key: "checkSendSize",
      value: function checkSendSize(stream) {}
    }, {
      key: "setBufferSize",
      value: function setBufferSize(rcvSize, sndSize) {
        this._maxSendPacketSize = sndSize;
      }
    }, {
      key: "toString",
      value: function toString() {
        return this._desc;
      }
    }, {
      key: "socketConnected",
      value: function socketConnected(e) {
        if (this._state == StateClosePending) {
          this.close();
          return;
        }

        Debug.assert(this._connectedCallback !== null);

        this._connectedCallback();
      }
    }, {
      key: "socketBytesAvailable",
      value: function socketBytesAvailable(buf) {
        Debug.assert(this._bytesAvailableCallback !== null);

        if (buf.byteLength > 0) {
          this._readBuffers.push(buf);

          if (this._registered) {
            this._bytesAvailableCallback();
          } else if (!this._hasBytesAvailable) {
            this._hasBytesAvailable = true;
          }
        }
      }
    }, {
      key: "socketClosed",
      value: function socketClosed(err) {
        if (this._state == StateClosePending) {
          this.close();
          return;
        }

        this._exception = translateError(this._state, err);

        if (this._state < StateConnected) {
          this._connectedCallback();
        } else if (this._registered) {
          this._bytesAvailableCallback();
        }
      }
    }], [{
      key: "createOutgoing",
      value: function createOutgoing(instance, secure, addr, resource) {
        var transceiver = new _WSTransceiver(instance);
        var url = secure ? "wss" : "ws";
        url += "://" + addr.host;

        if (addr.port !== 80) {
          url += ":" + addr.port;
        }

        url += resource ? resource : "/";
        transceiver._url = url;
        transceiver._fd = null;
        transceiver._addr = addr;
        transceiver._desc = "local address = <not available>\nremote address = " + addr.host + ":" + addr.port;
        transceiver._state = StateNeedConnect;
        transceiver._secure = secure;
        transceiver._exception = null;
        return transceiver;
      }
    }]);

    return WSTransceiver;
  }();
} else {
  _WSTransceiver = /*#__PURE__*/_createClass(function _WSTransceiver() {
    _classCallCheck(this, _WSTransceiver);
  });
}

Ice.WSTransceiver = _WSTransceiver;
exports.Ice = Ice;