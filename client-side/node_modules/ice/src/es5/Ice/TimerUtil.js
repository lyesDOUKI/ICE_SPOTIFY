"use strict";

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
var Ice = require("../Ice/ModuleRegistry").Ice;

var Timer = {};

if (typeof process != 'undefined') {
  Timer = /*#__PURE__*/_createClass(function Timer() {
    _classCallCheck(this, Timer);
  });
  Timer.setTimeout = setTimeout;
  Timer.clearTimeout = clearTimeout;
  Timer.setInterval = setInterval;
  Timer.clearInterval = clearInterval;
  Timer.setImmediate = setImmediate;
  Ice.Timer = Timer;
} else {
  var isIE = function isIE() {
    return navigator.userAgent.indexOf("MSIE") !== -1 || navigator.userAgent.match(/Trident.*rv:11\./);
  };

  var isEdge = function isEdge() {
    return /Edge/.test(navigator.userAgent);
  };

  var isWorker = function isWorker() {
    return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
  };

  //
  // Create a timer object that uses the default browser methods.
  //
  var createTimerObject = function createTimerObject() {
    var Timer = /*#__PURE__*/function () {
      function Timer() {
        _classCallCheck(this, Timer);
      }

      _createClass(Timer, null, [{
        key: "setTimeout",
        value: function (_setTimeout) {
          function setTimeout(_x, _x2) {
            return _setTimeout.apply(this, arguments);
          }

          setTimeout.toString = function () {
            return _setTimeout.toString();
          };

          return setTimeout;
        }(function (cb, ms) {
          return setTimeout(cb, ms);
        })
      }, {
        key: "clearTimeout",
        value: function (_clearTimeout) {
          function clearTimeout(_x3) {
            return _clearTimeout.apply(this, arguments);
          }

          clearTimeout.toString = function () {
            return _clearTimeout.toString();
          };

          return clearTimeout;
        }(function (id) {
          return clearTimeout(id);
        })
      }, {
        key: "setInterval",
        value: function (_setInterval) {
          function setInterval(_x4, _x5) {
            return _setInterval.apply(this, arguments);
          }

          setInterval.toString = function () {
            return _setInterval.toString();
          };

          return setInterval;
        }(function (cb, ms) {
          return setInterval(cb, ms);
        })
      }, {
        key: "clearInterval",
        value: function (_clearInterval) {
          function clearInterval(_x6) {
            return _clearInterval.apply(this, arguments);
          }

          clearInterval.toString = function () {
            return _clearInterval.toString();
          };

          return clearInterval;
        }(function (id) {
          return clearInterval(id);
        })
      }]);

      return Timer;
    }(); //
    // For Browsers that support setImmediate prefer that,
    // otherwise implement it using MessageChannel
    //


    if (isEdge() || isIE()) {
      Timer.setImmediate = function (cb) {
        setImmediate(cb);
      };
    } else {
      //
      // Should be only call for workers
      //
      var channel = new MessageChannel();

      channel.port1.onmessage = function (event) {
        var id = event.data;

        var cb = _timers.get(id);

        if (cb !== undefined) {
          cb.call();

          _timers.delete(id);
        }
      };

      Timer.setImmediate = function (cb) {
        var id = nextId();

        _timers.set(id, cb);

        channel.port2.postMessage(id);
      };
    }

    return Timer;
  };

  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var _nextId = 0;

  var nextId = function nextId() {
    if (_nextId == MAX_SAFE_INTEGER) {
      _nextId = 0;
    }

    return _nextId++;
  };

  var _timers = new Map();

  var _SetTimeoutType = 0;
  var _SetIntervalType = 1;
  var _SetImmediateType = 2;
  var _ClearTimeoutType = 3;
  var _ClearIntervalType = 4;
  var worker;

  var _Timer = /*#__PURE__*/function () {
    function _Timer() {
      _classCallCheck(this, _Timer);
    }

    _createClass(_Timer, null, [{
      key: "setTimeout",
      value: function setTimeout(cb, ms) {
        var id = nextId();

        _timers.set(id, cb);

        worker.postMessage({
          type: _SetTimeoutType,
          id: id,
          ms: ms
        });
        return id;
      }
    }, {
      key: "clearTimeout",
      value: function clearTimeout(id) {
        _timers.delete(id);

        worker.postMessage({
          type: _ClearTimeoutType,
          id: id
        });
      }
    }, {
      key: "setInterval",
      value: function setInterval(cb, ms) {
        var id = nextId();

        _timers.set(id, cb);

        worker.postMessage({
          type: _SetIntervalType,
          id: id,
          ms: ms
        });
        return id;
      }
    }, {
      key: "clearInterval",
      value: function clearInterval(id) {
        _timers.delete(id);

        worker.postMessage({
          type: _ClearIntervalType,
          id: id
        });
      }
    }, {
      key: "setImmediate",
      value: function setImmediate(cb) {
        var id = nextId();

        _timers.set(id, cb);

        worker.postMessage({
          type: _SetImmediateType,
          id: id
        });
        return id;
      }
    }, {
      key: "onmessage",
      value: function onmessage(e) {
        var cb = _timers.get(e.data.id);

        if (cb !== undefined) {
          cb.call();

          if (e.data.type !== _SetIntervalType) {
            _timers.delete(e.data.id);
          }
        }
      }
    }]);

    return _Timer;
  }();

  var workerCode = function workerCode() {
    return "(" + function () {
      //
      // jshint worker: true
      //
      var _wSetTimeoutType = 0;
      var _wSetIntervalType = 1;
      var _wSetImmediateType = 2;
      var _wClearTimeoutType = 3;
      var _wClearIntervalType = 4;
      var timers = {};

      self.onmessage = function (e) {
        if (e.data.type == _wSetTimeoutType) {
          timers[e.data.id] = setTimeout(function () {
            return self.postMessage(e.data);
          }, e.data.ms);
        } else if (e.data.type == _wSetIntervalType) {
          timers[e.data.id] = setInterval(function () {
            return self.postMessage(e.data);
          }, e.data.ms);
        } else if (e.data.type == _wSetImmediateType) {
          self.postMessage(e.data);
        } else if (e.data.type == _wClearTimeoutType) {
          clearTimeout(timers[e.data.id]);
          delete timers[e.data.id];
        } else if (e.data.type == _wClearIntervalType) {
          clearInterval(timers[e.data.id]);
          delete timers[e.data.id];
        }
      }; //
      // jshint worker: false
      //

    }.toString() + "());";
  };

  if (isIE()) {
    //
    // With IE always use the setInterval/setTimeout browser functions directly
    //
    Ice.Timer = createTimerObject();
  } else if (isWorker()) {
    //
    // If we are running in a worker don't spawn a separate worker for the timer
    //
    Ice.Timer = createTimerObject();
  } else if (worker === undefined) {
    var url = URL.createObjectURL(new Blob([workerCode()], {
      type: 'text/javascript'
    }));
    worker = new Worker(url);
    worker.onmessage = _Timer.onmessage;
    Ice.Timer = _Timer;
  }
}

module.exports.Ice = Ice;